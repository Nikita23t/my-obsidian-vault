
### Алгоритмы сортировки: пузырьковая, быстрая, сортировка слиянием

Разберем три ключевых алгоритма сортировки и их реализацию на JavaScript (Node.js).

---

### 1. Пузырьковая сортировка (Bubble Sort)
**Принцип:**  
Сравнивает соседние элементы и меняет их местами, если они не в порядке. На каждой итерации "всплывает" наибольший элемент в конец.  
**Сложность:**  
- **Худший случай:** O(n²)  
- **Лучший случай (уже отсортированный массив):** O(n)  

**Реализация:**
```javascript
function bubbleSort(arr) {
  let swapped;
  for (let i = 0; i < arr.length; i++) {
    swapped = false;
    for (let j = 0; j < arr.length - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; // Деструктуризация для обмена
        swapped = true;
      }
    }
    if (!swapped) break; // Оптимизация: выход, если массив уже отсортирован
  }
  return arr;
}
```

**Пример:**
```javascript
console.log(bubbleSort([5, 3, 8, 1, 2])); // [1, 2, 3, 5, 8]
```

---

### 2. Быстрая сортировка (Quick Sort)
**Принцип:**  
Алгоритм «разделяй и властвуй»:
1. Выбирает **опорный элемент** (pivot).
2. Делит массив на две части: элементы меньше опорного и больше/равные.
3. Рекурсивно сортирует обе части.

**Сложность:**  
- **Средний случай:** O(n log n)  
- **Худший случай (плохой выбор pivot):** O(n²)  

**Реализация (с выбором среднего элемента как pivot):**
```javascript
function quickSort(arr) {
  if (arr.length <= 1) return arr;

  const pivotIndex = Math.floor(arr.length / 2);
  const pivot = arr[pivotIndex];
  const left = [];
  const right = [];

  for (let i = 0; i < arr.length; i++) {
    if (i === pivotIndex) continue;
    arr[i] < pivot ? left.push(arr[i]) : right.push(arr[i]);
  }

  return [...quickSort(left), pivot, ...quickSort(right)];
}
```

**Пример:**
```javascript
console.log(quickSort([10, -2, 7, 5, 3])); // [-2, 3, 5, 7, 10]
```

---

### 3. Сортировка слиянием (Merge Sort)
**Принцип:**  
1. Рекурсивно делит массив на две половины.
2. Сортирует каждую половину.
3. Сливает отсортированные половины в один массив.

**Сложность:**  
Всегда O(n log n).  
**Память:** O(n) (требуется дополнительный массив для слияния).

**Реализация:**
```javascript
function mergeSort(arr) {
  if (arr.length <= 1) return arr;

  const mid = Math.floor(arr.length / 2);
  const left = mergeSort(arr.slice(0, mid));
  const right = mergeSort(arr.slice(mid));

  return merge(left, right);
}

function merge(left, right) {
  let result = [];
  let i = 0, j = 0;

  while (i < left.length && j < right.length) {
    result.push(left[i] < right[j] ? left[i++] : right[j++]);
  }

  return result.concat(left.slice(i)).concat(right.slice(j));
}
```

**Пример:**
```javascript
console.log(mergeSort([6, 1, 9, 2, 5])); // [1, 2, 5, 6, 9]
```

---

### Сравнение алгоритмов
| Параметр          | Пузырьковая | Быстрая | Слиянием |
|-------------------|-------------|---------|----------|
| **Сложность**     | O(n²)       | O(n log n) | O(n log n) |
| **Память**        | O(1)        | O(log n) | O(n)     |
| **Стабильность**  | Да          | Нет      | Да       |
| **Использование** | Учебные примеры | Практические задачи | Большие данные, стабильность |

---

### Советы для Node.js
1. **Встроенный метод `sort()`:**  
   JavaScript предоставляет встроенную сортировку (`arr.sort((a, b) => a - b)`), которая в большинстве движков (например, V8) использует **Timsort** (гибрид сортировки слиянием и вставками). Для большинства задач лучше использовать его.
2. **Выбор алгоритма:**  
   - **Малые данные:** Пузырьковая (только для обучения).  
   - **Универсальные задачи:** Быстрая сортировка (быстрее на практике).  
   - **Большие данные и стабильность:** Сортировка слиянием.  
3. **Осторожно с рекурсией:**  
   Для очень больших массивов в Quick Sort и Merge Sort возможны переполнения стека. Используйте итеративные версии или ограничивайте глубину рекурсии.