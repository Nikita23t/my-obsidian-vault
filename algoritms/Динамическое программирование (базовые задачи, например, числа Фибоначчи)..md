
### Динамическое программирование (ДП) и числа Фибоначчи

Динамическое программирование — это метод решения задач путем разбиения их на более мелкие подзадачи, **сохранения результатов** этих подзадач и повторного использования их для оптимизации вычислений. Рассмотрим его на примере чисел Фибоначчи.

---

### 1. Классическая задача: числа Фибоначчи
**Формула:**  
`F(n) = F(n-1) + F(n-2)`, где `F(0) = 0`, `F(1) = 1`.

#### a. Наивная рекурсия (плохой подход)
```javascript
function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n-1) + fibonacci(n-2);
}

console.log(fibonacci(10)); // 55
```
**Проблема:**  
Множество повторных вычислений. Например, для `fib(5)` дерево вызовов выглядит так:

```
fib(5)
├─ fib(4)
│  ├─ fib(3)
│  │  ├─ fib(2)
│  │  │  ├─ fib(1)
│  │  │  └─ fib(0)
│  │  └─ fib(1)
│  └─ fib(2)
└─ fib(3)
```

**Сложность:** O(2ⁿ) — экспоненциальная.

---

### 2. Решение через ДП
#### a. Мемоизация (сверху вниз)
Сохраняем уже вычисленные значения в кэше (объекте или массиве).

```javascript
function fibonacciMemo(n, memo = {}) {
  if (n <= 1) return n;
  if (memo[n] !== undefined) return memo[n]; // Используем кэш

  memo[n] = fibonacciMemo(n-1, memo) + fibonacciMemo(n-2, memo);
  return memo[n];
}

console.log(fibonacciMemo(50)); // 12586269025 (мгновенно)
```
**Сложность:** O(n) — линейная.

---

#### b. Итеративный подход (снизу вверх)
Вычисляем числа последовательно, сохраняя только предыдущие два значения.

```javascript
function fibonacciIterative(n) {
  if (n <= 1) return n;
  
  let a = 0, b = 1;
  for (let i = 2; i <= n; i++) {
    const c = a + b;
    a = b;
    b = c;
  }
  return b;
}

console.log(fibonacciIterative(50)); // 12586269025
```
**Сложность:** O(n), **память:** O(1).

---

### 3. Ключевые идеи ДП
1. **Оптимальная подструктура:** Решение задачи можно выразить через решения подзадач.
2. **Перекрывающиеся подзадачи:** Одни и те же подзадачи решаются многократно.
3. **Сохранение результатов:** Избегаем повторных вычислений через кэш (мемоизация) или итеративное заполнение таблицы.

---

### 4. Где еще применяется ДП?
- **Расстояние Левенштейна** (редакционное расстояние между строками).
- **Задача о рюкзаке** (выбор предметов с максимальной ценностью).
- **Поиск самой длинной общей подпоследовательности.**
- **Оптимизация маршрутов** (например, алгоритм Флойда-Уоршелла).

---

### Пример: ДП для задачи о кузнечике
**Задача:** Кузнечик прыгает на 1 или 2 шага. Сколько способов добраться до ступеньки `n`?

**Решение:**
```javascript
function countWays(n) {
  const dp = new Array(n+1).fill(0);
  dp[0] = 1; // Базовый случай
  dp[1] = 1;

  for (let i = 2; i <= n; i++) {
    dp[i] = dp[i-1] + dp[i-2];
  }
  return dp[n];
}

console.log(countWays(5)); // 8
```
**Аналогия:** Числа Фибоначчи со сдвигом.

---

### Итог
- **ДП** — мощный инструмент для оптимизации рекурсивных задач.
- **Мемоизация** и **табулирование** — две основные техники.
- Всегда анализируйте задачу на наличие перекрывающихся подзадач и оптимальной подструктуры.