### Рекурсия и оптимизация хвостовых вызовов (TCO)

---

#### 1. Рекурсия: основы
**Рекурсия** — подход, при котором функция вызывает **саму себя** для решения подзадачи.  
**Примеры задач:** обход деревьев, вычисление факториала, числа Фибоначчи.

**Пример (факториал):**
```javascript
function factorial(n) {
  if (n <= 1) return 1;
  return n * factorial(n - 1); // Рекурсивный вызов НЕ в хвостовой позиции
}

console.log(factorial(5)); // 120
```

**Проблема:**  
Каждый рекурсивный вызов добавляет кадр в **стек вызовов**. При большой глубине рекурсии это вызывает **переполнение стека**:
```javascript
factorial(100000); // RangeError: Maximum call stack size exceeded
```

---

#### 2. Хвостовая рекурсия
**Хвостовой вызов** — рекурсивный вызов, который является **последней операцией** в функции.  
**Оптимизация хвостовых вызовов (TCO)** позволяет повторно использовать текущий кадр стека, избегая его роста.

**Перепишем факториал с хвостовой рекурсией:**
```javascript
function factorialTail(n, acc = 1) {
  if (n <= 1) return acc;
  return factorialTail(n - 1, n * acc); // Хвостовой вызов
}
```

**Как это работает:**  
- `acc` (аккумулятор) хранит промежуточный результат.  
- Последняя операция — рекурсивный вызов, который можно оптимизировать.

---

#### 3. Поддержка TCO в JavaScript
- Спецификация ES6 формально включает TCO, но **на практике** большинство движков (V8, SpiderMonkey) его **не реализовали**.  
- Проверить поддержку можно через выполнение:
```javascript
function testTCO() {
  "use strict";
  return (function f(n) { return n === 0 ? 0 : f(n - 1); })(1000000);
}

testTCO(); // Если не будет ошибки — TCO поддерживается.
```

**Важно:**  
В Node.js и браузерах вызов `factorialTail(100000)` всё равно завершится ошибкой стека, так как TCO не активирован.

---

#### 4. Обход ограничений: итеративный подход
Если TCO недоступен, рекурсию можно преобразовать в **цикл**:

```javascript
function factorialIterative(n) {
  let acc = 1;
  for (let i = n; i > 1; i--) {
    acc *= i;
  }
  return acc;
}

console.log(factorialIterative(100000)); // Работает (но результат будет Infinity)
```

---

#### 5. Когда использовать рекурсию?
| **Плюсы**                            | **Минусы**                          |
|--------------------------------------|--------------------------------------|
| Упрощает код для задач с вложенностью | Риск переполнения стека             |
| Идеально для деревьев/графов         | Медленнее циклов в некоторых случаях |

**Советы:**  
- Используйте рекурсию для **алгоритмов с ветвлением** (например, обход файловой системы).  
- Для **линейной рекурсии** (как факториал) предпочитайте циклы или мемоизацию.  

---

### Итог
- **Хвостовая рекурсия** — мощный инструмент, но в JavaScript он **практически недоступен**.  
- **Альтернативы:**  
  - Циклы.  
  - Мемоизация (кэширование результатов).  
  - Изменение алгоритма на итеративный.  
- Всегда проверяйте глубину рекурсии и учитывайте ограничения среды выполнения.